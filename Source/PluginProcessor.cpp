/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin processor.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"


//==============================================================================
BVerbAudioProcessor::BVerbAudioProcessor(){
    dummyIndex = 1;
    remainBuffer = new RemainBuffer(2,490000);
    accBuff = new AccuBuffer();
    StereoHeadTailPartConv* kernel1 = new StereoHeadTailPartConv(remainBuffer, accBuff, getNonDummyIndex());
    StereoHeadTailPartConv* kernel2 = new StereoHeadTailPartConv(remainBuffer, accBuff, getDummyIndex());
    convkernells.add(kernel1);
    convkernells.add(kernel2);
    changeConvKernellFlag = false;
    prepareForFutureSynthFlag = false;
    
    IRLoader = new BFormatWavLoader();
    virtualMicSynthL = new VMS();
    virtualMicSynthR = new VMS();
    
    //--------------- GUI PARAMETERS --------------------
    //------------------ GENERAL ------------------------
    parameters.add(new teragon::BooleanParameter("IR"));
    parameters.add(new teragon::BooleanParameter("MicTechBlum"));
    parameters.add(new teragon::BooleanParameter("MicTechXY"));
    parameters.add(new teragon::BooleanParameter("MicTechMidSide"));
    parameters.add(new teragon::BooleanParameter("MicTechFree",true));
    
    //------------------ MIC 1 ------------------------
    parameters.add(new teragon::FloatParameter("azimuth1",-180, 180, 0));
    parameters.add(new teragon::FloatParameter("elevation1",-90, 90, 0));
    parameters.add(new teragon::BooleanParameter("polarOmni1",true));
    parameters.add(new teragon::BooleanParameter("polarCard1"));
    parameters.add(new teragon::BooleanParameter("polarSuper1"));
    parameters.add(new teragon::BooleanParameter("polarOcho1"));
    
    //------------------ MIC 2 ------------------------
    parameters.add(new teragon::FloatParameter("azimuth2",-180, 180, 0));
    parameters.add(new teragon::FloatParameter("elevation2",-90, 90, 0));
    parameters.add(new teragon::BooleanParameter("polarOmni2",true));
    parameters.add(new teragon::BooleanParameter("polarCard2"));
    parameters.add(new teragon::BooleanParameter("polarSuper2"));
    parameters.add(new teragon::BooleanParameter("polarOcho2"));
    
    //------------ GENERAL PARAMETERS -----------------
    parameters.add(new teragon::BooleanParameter("irLoaded",false));
    teragon::ParameterString path = "IR Wav file not selected";
    parameters.add(new teragon::StringParameter("IR Path", path));
    parameters["IR Path"]->addObserver(this);
    
    parameters.pause();
}

//==============================================================================
BVerbAudioProcessor::~BVerbAudioProcessor(){
}

//==============================================================================
const String BVerbAudioProcessor::getName() const{
    return JucePlugin_Name;
}

bool BVerbAudioProcessor::acceptsMidi() const{
   #if JucePlugin_WantsMidiInput
    return true;
   #else
    return false;
   #endif
}

bool BVerbAudioProcessor::producesMidi() const{
   #if JucePlugin_ProducesMidiOutput
    return true;
   #else
    return false;
   #endif
}

int BVerbAudioProcessor::getNumPrograms(){
    return 1;   // NB: some hosts don't cope very well if you tell them there are 0 programs,
                // so this should be at least 1, even if you're not really implementing programs.
}

//==============================================================================
int BVerbAudioProcessor::getNumParameters() {
    return parameters.size();
}

float BVerbAudioProcessor::getParameter(int index) {
    return (float)parameters[index]->getScaledValue();
}

void BVerbAudioProcessor::setParameter(int index, float newValue) {
    parameters.setScaled((const size_t)index, newValue);
}

const String BVerbAudioProcessor::getParameterName(int index) {
    return parameters[index]->getName();
}

const String BVerbAudioProcessor::getParameterText(int index) {
    return parameters[index]->getDisplayText();
}

bool BVerbAudioProcessor::isMetaParameter(int index) const {
    return (dynamic_cast<teragon::VoidParameter *>(parameters[index]) == nullptr);
}

//==============================================================================
void BVerbAudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock){
    parameters.resume();
}

//==============================================================================
void BVerbAudioProcessor::releaseResources(){
    // When playback stops, you can use this as an opportunity to free up any
    // spare memory, etc.
    parameters.pause();
}

//==============================================================================
void BVerbAudioProcessor::processBlock (AudioSampleBuffer& buffer, MidiBuffer& midiMessages){
    parameters.processRealtimeEvents();
    if (changeConvKernellFlag){
        setDummyIndex(getNonDummyIndex());
        changeConvKernellFlag = false;
        if (prepareForFutureSynthFlag){
            convkernells[getDummyIndex()]->prepareForFutureSynthIR(IRLoader->getIRSize());
        }
    }
    int currentWorkingKernell = getNonDummyIndex();
    
    if (convkernells[currentWorkingKernell]->getBffSize() != buffer.getNumSamples()) {
        convkernells[currentWorkingKernell]->setBffSize(buffer.getNumSamples());
        convkernells[getDummyIndex()]->setBffSize(buffer.getNumSamples());
    }
    
    for (int i = getTotalNumInputChannels(); i < getTotalNumOutputChannels(); i++)
        buffer.clear (i, 0, buffer.getNumSamples());
    
    convkernells[currentWorkingKernell]->processBlock(buffer.getWritePointer(0), buffer.getWritePointer(1));
}

//==============================================================================
void BVerbAudioProcessor::onParameterUpdated(const teragon::Parameter *parameter) {
    if(parameter->getName() == "IR Path") {
        teragon::Parameter *lastIRLocation = parameters["IR Path"];
        File irLocation(lastIRLocation->getDisplayText());
        if(irLocation.exists()) {
            //...................... CODIGO PARA PODER USAR IR SINTETIZADA CON MIC VIRTUAL .............................
            if(parameters.get("polarCard1")->getValue()){
                virtualMicSynthL->set_d(1.0f);
                Logger::writeToLog ("polarCard1: ");
            }else if (parameters.get("polarSuper1")->getValue()){
                virtualMicSynthL->set_d(1.5f);
                Logger::writeToLog ("polarSuper1: ");
            }else if (parameters.get("polarOcho1")->getValue()){
                virtualMicSynthL->set_d(2.0f);
                Logger::writeToLog ("polarOcho1: ");
            }
            
            if (parameters.get("polarCard2")->getValue()){
                virtualMicSynthR->set_d(1.0f);
                Logger::writeToLog ("polarCard2: ");
            }else if (parameters.get("polarSuper2")->getValue()){
                virtualMicSynthR->set_d(1.5f);
                Logger::writeToLog ("polarSuper2: ");
            }else if (parameters.get("polarOcho2")->getValue()){
                virtualMicSynthR->set_d(2.0f);
                Logger::writeToLog ("polarOcho2: ");
            }
            
            if (parameters.get("MicTechBlum")->getValue()){
                virtualMicSynthL->set_theta(parameters.get("azimuth1")->getValue() - 45.0f);
                virtualMicSynthR->set_theta(parameters.get("azimuth1")->getValue() + 45.0f);
                virtualMicSynthL->set_phi(parameters.get("elevation1")->getValue());
                virtualMicSynthR->set_phi(parameters.get("elevation1")->getValue());
            }else if (parameters.get("MicTechXY")->getValue()){
                virtualMicSynthL->set_theta(parameters.get("azimuth1")->getValue() - 45.0f);
                virtualMicSynthR->set_theta(parameters.get("azimuth1")->getValue() + 45.0f);
                virtualMicSynthL->set_phi(parameters.get("elevation1")->getValue());
                virtualMicSynthR->set_phi(parameters.get("elevation1")->getValue());
            }else if (parameters.get("MicTechMidSide")->getValue()){
                virtualMicSynthL->set_theta(parameters.get("azimuth1")->getValue());
                virtualMicSynthR->set_theta(parameters.get("azimuth1")->getValue() - 90.0f);
                virtualMicSynthL->set_phi(parameters.get("elevation1")->getValue());
                virtualMicSynthR->set_phi(parameters.get("elevation1")->getValue());
            }else if (parameters.get("MicTechFree")->getValue()){
                virtualMicSynthL->set_theta(parameters.get("azimuth1")->getValue());
                virtualMicSynthR->set_theta(parameters.get("azimuth2")->getValue());
                virtualMicSynthL->set_phi(parameters.get("elevation1")->getValue());
                virtualMicSynthR->set_phi(parameters.get("elevation2")->getValue());
            }
            
            IRLoader->readFile(irLocation.getFullPathName());
            
            convkernells[getNonDummyIndex()]->prepareForIRLoad(IRLoader->getIRSize());
            virtualMicSynthL->synth(IRLoader->getIRSize(), IRLoader->getReadPointer2Channel(1), IRLoader->getReadPointer2Channel(2), IRLoader->getReadPointer2Channel(3), IRLoader->getReadPointer2Channel(0), convkernells[getNonDummyIndex()]->getIrAudioBufferPointer(0));
            virtualMicSynthR->synth(IRLoader->getIRSize(), IRLoader->getReadPointer2Channel(1), IRLoader->getReadPointer2Channel(2), IRLoader->getReadPointer2Channel(3), IRLoader->getReadPointer2Channel(0), convkernells[getNonDummyIndex()]->getIrAudioBufferPointer(1));
            convkernells[getNonDummyIndex()]->resetPartitions();
            
            convkernells[getDummyIndex()]->prepareForFutureSynthIR(IRLoader->getIRSize());
            parameters["IR Path"]->removeObserver(this);
        }
    }
}

//==============================================================================
bool BVerbAudioProcessor::hasEditor() const{
    return true; // (change this to false if you choose to not supply an editor)
}

//==============================================================================
AudioProcessorEditor* BVerbAudioProcessor::createEditor(){
    return new BVerbAudioProcessorEditor (*this, parameters,Resources::getCache());
}

//==============================================================================
void BVerbAudioProcessor::getStateInformation (MemoryBlock& destData)
{
    XmlElement xml(getName());
    for(size_t i = 0; i < parameters.size(); ++i) {
        teragon::Parameter *parameter = parameters[i];
        const String attributeName = parameter->getSafeName();
        
        if(dynamic_cast<teragon::StringParameter *>(parameter) != nullptr) {
            // Convert parameter strings to juce strings
            const String value = parameter->getDisplayText();
            xml.setAttribute(attributeName, value);
        }
        else if(dynamic_cast<teragon::IntegerParameter *>(parameter) != nullptr) {
            // Serialize integer parameters with the proper call
            xml.setAttribute(attributeName, (int)parameter->getValue());
        }
        else if(dynamic_cast<teragon::VoidParameter *>(parameter) != nullptr) {
            // Skip void parameters, these don't contain any interesting values
            continue;
        }
        else {
            // All other parameters can be serialized as doubles
            xml.setAttribute(attributeName, (double)parameter->getValue());
        }
    }
    
    // Save XML data to disk (via the host, that is)
    copyXmlToBinary(xml, destData);
}

//==============================================================================
void BVerbAudioProcessor::setStateInformation (const void* data, int sizeInBytes){
    ScopedPointer<XmlElement> xmlState(getXmlFromBinary(data, sizeInBytes));
    if(xmlState != 0 && xmlState->hasTagName(getName())) {
        for(size_t i = 0; i < parameters.size(); i++) {
            teragon::Parameter *parameter = parameters[i];
            const String attributeName = parameter->getSafeName();
            // Check to make sure that this parameter exists in the saved XML state. We
            // could run into problems when a newer version of this plugin introduces new
            // parameters which may not necessarily exist in saved documents from older
            // versions. In such cases, new parameters will retain their default values.
            if(xmlState->hasAttribute(attributeName)) {
                if(dynamic_cast<teragon::StringParameter *>(parameter) != nullptr) {
                    // Convert juce strings to binary data events
                    juce::String value = xmlState->getStringAttribute(attributeName);
                    parameters.setData(parameter, value.toStdString().c_str(),(const size_t)value.length());
                }
                else if(dynamic_cast<teragon::IntegerParameter *>(parameter) != nullptr) {
                    // Treat integer parameters as real integers
                    parameters.set(parameter, xmlState->getIntAttribute(attributeName));
                }
                else {
                    // Everything else can be handled as a double
                    parameters.set(parameter, xmlState->getDoubleAttribute(attributeName));
                }
            }
        }
        // Force parameters to be applied immediately
        parameters.processRealtimeEvents();
    }
}

//==============================================================================
// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new BVerbAudioProcessor();
}
